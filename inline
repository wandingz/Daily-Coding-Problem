{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def lengthOfLongestSubstring(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        start, largest = 0, 0\n",
    "        seen = {}\n",
    "        for i,x in enumerate(s):\n",
    "            if x in seen:\n",
    "                start = max(start, seen[x]+1)\n",
    "            seen[x] = i\n",
    "            longest = max(longest, i+1-start)\n",
    "            resturn longest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def lengthOfLongestSubstring(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        start, largest = 0, 0\n",
    "        seen = {}\n",
    "        for i,x in enumerate(s):\n",
    "            if x in seen:\n",
    "                start = max(start, seen[x]+1)\n",
    "            seen[x] = i\n",
    "            longest = max(longest, i+1-start)\n",
    "            return longest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "Solution().lengthOfLongestSubstring('abcabcbb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def lengthOfLongestSubstring(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        start, largest = 0, 0\n",
    "        seen = {}\n",
    "        for i,x in enumerate(s):\n",
    "            if x in seen:\n",
    "                start = max(start, seen[x]+1)\n",
    "            seen[x] = i\n",
    "            longest = max(longest, i+1-start)\n",
    "        return longest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "Solution().lengthOfLongestSubstring('abcabcbb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def lengthOfLongestSubstring(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        start, longest = 0, 0\n",
    "        seen = {}\n",
    "        for i,x in enumerate(s):\n",
    "            if x in seen:\n",
    "                start = max(start, seen[x]+1)\n",
    "            seen[x] = i\n",
    "            longest = max(longest, i+1-start)\n",
    "        return longest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "Solution().lengthOfLongestSubstring('abcabcbb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'abcabcbb'\n",
    "s = 'pwwkew'\n",
    "Solution().lengthOfLongestSubstring(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'abcabcbb'\n",
    "s = 'bbbbbb'\n",
    "# s = 'pwwkew'\n",
    "Solution().lengthOfLongestSubstring(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'abcabcbb'\n",
    "s = 'bbbbbb'\n",
    "s = 'pwwkew'\n",
    "Solution().lengthOfLongestSubstring(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def lengthOfLongestSubstring(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: int\n",
    "        \"\"\"\n",
    "        if len(s) <= 1:\n",
    "            return len(s)\n",
    "        \n",
    "        start, longest = 0, 0\n",
    "        seen = {}\n",
    "        for i,x in enumerate(s):\n",
    "            if x in seen:\n",
    "                start = max(start, seen[x]+1)\n",
    "            seen[x] = i\n",
    "            longest = max(longest, i+1-start)\n",
    "        return longest"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'abcabcbb'\n",
    "s = 'bbbbbb'\n",
    "s = 'pwwkew'\n",
    "Solution().lengthOfLongestSubstring(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'abcabcbb'\n",
    "s = 'bbbbbb'\n",
    "s = 'pwwkew'\n",
    "s = 'abcbadbbc'\n",
    "Solution().lengthOfLongestSubstring(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "[1,2,3] + [3,4,5]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        x = (r - l) // 2\n",
    "        nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        x = (r - l) // 2\n",
    "        nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        x = (r - l) // 2\n",
    "        nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 3]\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        x = (l + r) // 2\n",
    "        nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 3]\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if m == 0:\n",
    "            mid = n // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "        if n == 0:\n",
    "            mid = m // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        x = (l + r) // 2\n",
    "        nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 3]\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if m == 0:\n",
    "            mid = n // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "        if n == 0:\n",
    "            mid = m // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "#         x = (l + r) // 2\n",
    "#         nums[x], nums[l] = nums[l], nums[x]\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 3]\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "2//2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 2]\n",
    "nums2 = [3, 4]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if m == 0:\n",
    "            mid = n // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "        if n == 0:\n",
    "            mid = m // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 2]\n",
    "nums2 = [3, 4]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa[-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa[:-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa[:-1].pop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa.pop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa.pop()\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa.pop()\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "if 4 == aa.pop():\n",
    "    continue\n",
    "    \n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "if 4 == aa.pop():\n",
    "    print(aa)\n",
    "    \n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa.pop()\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "aa[:-1].pop()\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "aa = [1,2,3,4]\n",
    "if 4 != aa.pop():\n",
    "    print('1')\n",
    "aa"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums = [1]\n",
    "n = len(nums)\n",
    "mid = n // 2\n",
    "mid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "(nums1[mid] + nums1[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1[mid], nums1[~mid]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums = [1]\n",
    "n = len(nums)\n",
    "mid = n // 2\n",
    "mid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "1//2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums[mid], nums[~mid]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "(nums1[mid] + nums1[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "(nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums = [1]\n",
    "n = len(nums)\n",
    "mid = n // 2\n",
    "mid"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums[mid], nums[~mid]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "(nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1, 2]\n",
    "nums2 = [3, 4]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [3]\n",
    "nums2 = [-2, -1]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [3]\n",
    "nums2 = [-2, -1]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r and p < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.partition(nums, l, p-1)\n",
    "            self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [3]\n",
    "nums2 = [-2, -1]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [3]\n",
    "nums2 = [-2, -1]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "            return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [3]\n",
    "nums2 = [-2, -1]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p)\n",
    "            if p < r:\n",
    "                self.partition(nums, p, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            print(p, nums)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        print(p, nums)\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        print(p, nums)\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            if p > l:\n",
    "                self.partition(nums, l, p-1)\n",
    "            if p < r:\n",
    "                self.partition(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "    # random choose the median & then switch it to the very front\n",
    "    x = random.choice(range(lo, hi))\n",
    "    arr[x], arr[lo] = arr[lo], arr[x]\n",
    "    # start the pivot from the very front & gradually move the smallers to the front\n",
    "    p = lo\n",
    "    for i in range(lo+1, hi+1):\n",
    "        if arr[i] < arr[lo]:\n",
    "            p += 1\n",
    "            arr[i], arr[p] = arr[p], arr[i]\n",
    "    # switch the median back to the median position\n",
    "    arr[lo], arr[p] = arr[p], arr[lo]\n",
    "    return p\n",
    "\n",
    "def quick_sort(arr, lo, hi):\n",
    "    if lo < hi:\n",
    "        p = partition(arr, lo, hi)\n",
    "        print(p, arr)\n",
    "        quick_sort(arr, lo, p-1)\n",
    "        quick_sort(arr, p+1, hi)\n",
    "        return arr\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    arr = [1,2,3,1,2,2\n",
    "          ]\n",
    "    print('array:', arr)\n",
    "    print('step by step:')\n",
    "    print('sorted:', quick_sort(arr, 0, len(arr)-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "    # random choose the median & then switch it to the very front\n",
    "    x = random.choice(range(lo, hi))\n",
    "    arr[x], arr[lo] = arr[lo], arr[x]\n",
    "    # start the pivot from the very front & gradually move the smallers to the front\n",
    "    p = lo\n",
    "    for i in range(lo+1, hi+1):\n",
    "        if arr[i] < arr[lo]:\n",
    "            p += 1\n",
    "            arr[i], arr[p] = arr[p], arr[i]\n",
    "    # switch the median back to the median position\n",
    "    arr[lo], arr[p] = arr[p], arr[lo]\n",
    "    return p\n",
    "\n",
    "def quick_sort(arr, lo, hi):\n",
    "    if lo < hi:\n",
    "        p = partition(arr, lo, hi)\n",
    "        print(p, arr)\n",
    "        quick_sort(arr, lo, p-1)\n",
    "        quick_sort(arr, p+1, hi)\n",
    "        return arr\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    arr = [1,2,3,1,2,2]\n",
    "    print('array:', arr)\n",
    "    print('step by step:')\n",
    "    print('sorted:', quick_sort(arr, 0, len(arr)-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "    # random choose the median & then switch it to the very front\n",
    "#     x = random.choice(range(lo, hi))\n",
    "#     arr[x], arr[lo] = arr[lo], arr[x]\n",
    "#     # start the pivot from the very front & gradually move the smallers to the front\n",
    "    p = lo\n",
    "    for i in range(lo+1, hi+1):\n",
    "        if arr[i] < arr[lo]:\n",
    "            p += 1\n",
    "            arr[i], arr[p] = arr[p], arr[i]\n",
    "    # switch the median back to the median position\n",
    "    arr[lo], arr[p] = arr[p], arr[lo]\n",
    "    return p\n",
    "\n",
    "def quick_sort(arr, lo, hi):\n",
    "    if lo < hi:\n",
    "        p = partition(arr, lo, hi)\n",
    "        print(p, arr)\n",
    "        quick_sort(arr, lo, p-1)\n",
    "        quick_sort(arr, p+1, hi)\n",
    "        return arr\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    arr = [1,2,3,1,2,2]\n",
    "    print('array:', arr)\n",
    "    print('step by step:')\n",
    "    print('sorted:', quick_sort(arr, 0, len(arr)-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "    # random choose the median & then switch it to the very front\n",
    "#     x = random.choice(range(lo, hi))\n",
    "#     arr[x], arr[lo] = arr[lo], arr[x]\n",
    "#     # start the pivot from the very front & gradually move the smallers to the front\n",
    "    p = lo\n",
    "    for i in range(lo+1, hi+1):\n",
    "        if arr[i] < arr[lo]:\n",
    "            p += 1\n",
    "            arr[i], arr[p] = arr[p], arr[i]\n",
    "    # switch the median back to the median position\n",
    "    arr[lo], arr[p] = arr[p], arr[lo]\n",
    "    return p\n",
    "\n",
    "def quick_sort(arr, lo, hi):\n",
    "    if lo < hi:\n",
    "        p = partition(arr, lo, hi)\n",
    "        print(p, arr)\n",
    "        quick_sort(arr, lo, p-1)\n",
    "        quick_sort(arr, p+1, hi)\n",
    "        return arr\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    arr = [1]\n",
    "    print('array:', arr)\n",
    "    print('step by step:')\n",
    "    print('sorted:', quick_sort(arr, 0, len(arr)-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "import random\n",
    "\n",
    "def partition(arr, lo, hi):\n",
    "    # random choose the median & then switch it to the very front\n",
    "#     x = random.choice(range(lo, hi))\n",
    "#     arr[x], arr[lo] = arr[lo], arr[x]\n",
    "#     # start the pivot from the very front & gradually move the smallers to the front\n",
    "    p = lo\n",
    "    for i in range(lo+1, hi+1):\n",
    "        if arr[i] < arr[lo]:\n",
    "            p += 1\n",
    "            arr[i], arr[p] = arr[p], arr[i]\n",
    "    # switch the median back to the median position\n",
    "    arr[lo], arr[p] = arr[p], arr[lo]\n",
    "    return p\n",
    "\n",
    "def quick_sort(arr, lo, hi):\n",
    "    if lo < hi:\n",
    "        p = partition(arr, lo, hi)\n",
    "        print(p, arr)\n",
    "        quick_sort(arr, lo, p-1)\n",
    "        quick_sort(arr, p+1, hi)\n",
    "        return arr\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    arr = []\n",
    "    print('array:', arr)\n",
    "    print('step by step:')\n",
    "    print('sorted:', quick_sort(arr, 0, len(arr)-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        print(nums)\n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.quick_sort(nums, l, p-1)\n",
    "            self.quick_sort(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    \n",
    "    def partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self.partition(nums, l, r)\n",
    "            self.quick_sort(nums, l, p-1)\n",
    "            self.quick_sort(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        nums = nums1 + nums2\n",
    "        nums.sort()\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        if not nums1:\n",
    "            nums = nums1\n",
    "        if not nums2:\n",
    "            nums = nums2\n",
    "        else:\n",
    "            nums = nums1 + nums2\n",
    "            nums.sort()\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2,3]\n",
    "nums2 = [1,2,2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2]\n",
    "nums2 = [3,4]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = []\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        if not nums1:\n",
    "            nums = nums1\n",
    "        if not nums2:\n",
    "            nums = nums2\n",
    "        else:\n",
    "            nums = nums1 + nums2\n",
    "            nums.sort()\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = []\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        if not nums1:\n",
    "            nums = nums1\n",
    "        elif not nums2:\n",
    "            nums = nums2\n",
    "        else:\n",
    "            nums = nums1 + nums2\n",
    "            nums.sort()\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = []\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        if not nums1:\n",
    "            nums = nums2\n",
    "        elif not nums2:\n",
    "            nums = nums1\n",
    "        else:\n",
    "            nums = nums1 + nums2\n",
    "            nums.sort()\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = []\n",
    "nums2 = [2]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        result = ''\n",
    "        for i in range(len(s)):\n",
    "            tmp = self.traverse(i, i)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "            tmp = self.traverse(i, i+1)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "        return result\n",
    "    def traverse(self, l, r):\n",
    "        if l >= 0 and r < len(s) and s[l] == s[r]:\n",
    "            l -= 1\n",
    "            r += 1\n",
    "        return s[l+1:r]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        result = ''\n",
    "        for i in range(len(s)):\n",
    "            tmp = self.traverse(s, i, i)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "            tmp = self.traverse(s, i, i+1)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "        return result\n",
    "    def traverse(self, s, l, r):\n",
    "        if l >= 0 and r < len(s) and s[l] == s[r]:\n",
    "            l -= 1\n",
    "            r += 1\n",
    "        return s[l+1:r]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        result = ''\n",
    "        for i in range(len(s)):\n",
    "            tmp = self.traverse(s, i, i)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "            tmp = self.traverse(s, i, i+1)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "        return result\n",
    "    def traverse(self, s, l, r):\n",
    "        while l >= 0 and r < len(s) and s[l] == s[r]:\n",
    "            l -= 1\n",
    "            r += 1\n",
    "        return s[l+1:r]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return\n",
    "        \n",
    "        result = ''\n",
    "        for i in range(len(s)):\n",
    "            tmp = self._spreadOut(s, i, i)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "            tmp = self._spreadOut(s, i, i+1)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "        return result\n",
    "    def _spreadOut(self, s, l, r):\n",
    "        while l >= 0 and r < len(s) and s[l] == s[r]:\n",
    "            l -= 1\n",
    "            r += 1\n",
    "        return s[l+1:r]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    \n",
    "    def _partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self._partition(nums, l, r)\n",
    "            self.quick_sort(nums, l, p-1)\n",
    "            self.quick_sort(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def findMedianSortedArrays(self, nums1, nums2):\n",
    "        \"\"\"\n",
    "        :type nums1: List[int]\n",
    "        :type nums2: List[int]\n",
    "        :rtype: float\n",
    "        \"\"\"\n",
    "        m, n = len(nums1), len(nums2)\n",
    "        if not nums1:\n",
    "            mid = n // 2\n",
    "            return (nums2[mid] + nums2[~mid]) / 2\n",
    "        if not nums2:\n",
    "            mid = m // 2\n",
    "            return (nums1[mid] + nums1[~mid]) / 2\n",
    "            \n",
    "        nums = nums1 + nums2\n",
    "        nums = self.quick_sort(nums, 0, len(nums)-1)\n",
    "        mid = len(nums) // 2\n",
    "        return (nums[mid] + nums[~mid]) / 2\n",
    "    \n",
    "    def _partition(self, nums, l, r):\n",
    "        p = l\n",
    "        for i in range(l+1, r+1):\n",
    "            if nums[i] < nums[l]:\n",
    "                p += 1\n",
    "                nums[p], nums[i] = nums[i], nums[p]\n",
    "        nums[p], nums[l] = nums[l], nums[p]\n",
    "        return p\n",
    "    def quick_sort(self, nums, l, r):\n",
    "        if l < r:\n",
    "            p = self._partition(nums, l, r)\n",
    "            self.quick_sort(nums, l, p-1)\n",
    "            self.quick_sort(nums, p+1, r)\n",
    "        return nums"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [],
   "source": [
    "nums1 = [1,2]\n",
    "nums2 = [3,4]\n",
    "Solution().findMedianSortedArrays(nums1, nums2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def longestPalindrome(self, s):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if not s:\n",
    "            return ''\n",
    "        \n",
    "        result = ''\n",
    "        for i in range(len(s)):\n",
    "            tmp = self._spreadOut(s, i, i)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "            tmp = self._spreadOut(s, i, i+1)\n",
    "            if len(tmp) > len(result):\n",
    "                result = tmp\n",
    "        return result\n",
    "    def _spreadOut(self, s, l, r):\n",
    "        while l >= 0 and r < len(s) and s[l] == s[r]:\n",
    "            l -= 1\n",
    "            r += 1\n",
    "        return s[l+1:r]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "s =  'babad'\n",
    "Solution().longestPalindrome(s)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "for i in range(nrows):\n",
    "    print((nrows-2)*2+2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "for i in range(nrows):\n",
    "    while start * ((nrows-2)*2+2) < len(s):\n",
    "        print(start * ((nrows-2)*2+2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "for i in range(nrows):\n",
    "    while start * ((nrows-2)*2+2) < len(s):\n",
    "        print(start * ((nrows-2)*2+2))\n",
    "        start += 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "row1 = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "row1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result += row1\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result += row1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        if x >= 0 and x < len(s):\n",
    "            result.append(x-1)\n",
    "            result.append(x+1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result += row1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        if x >= 0 and x < len(s):\n",
    "            result.append(x-1)\n",
    "            result.append(x+1)\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result += row1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        if x-1 > row1[0] and x+1 < row1[-1]:\n",
    "            result.append(x-1)\n",
    "            result.append(x+1)\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result += row1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        result.append(x-1)\n",
    "        result.append(x+1)\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        result.append(x-1)\n",
    "        result.append(x+1)\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result, row1 = [], []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    row1.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "for i in range(nrows):\n",
    "    for x in row1:\n",
    "        result.append(x-1)\n",
    "        result.append(x+1)\n",
    "result[1:-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        tmp.append(x-1)\n",
    "        tmp.append(x+1)\n",
    "    tmp = []\n",
    "result[1:-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        tmp.append(x-1)\n",
    "        tmp.append(x+1)\n",
    "    tmp = []\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "np.arange(9).reshape((3,3))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "arr = np.arange(9).reshape((3,3))\n",
    "arr[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        tmp.append(x-1)\n",
    "        tmp.append(x+1)\n",
    "    tmp = []\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "\n",
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "\n",
    "result[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 135,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        tmp.append(x-1)\n",
    "        tmp.append(x+1)\n",
    "    result.append(tmp[1:-1])\n",
    "    tmp = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {},
   "outputs": [],
   "source": [
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        tmp.append(x-1)\n",
    "        tmp.append(x+1)\n",
    "    result.append(tmp)\n",
    "    tmp = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [],
   "source": [
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {},
   "outputs": [],
   "source": [
    "nrows = 7\n",
    "s = 'PAYPALISHIRING'\n",
    "start = 0\n",
    "result = []\n",
    "tmp = []\n",
    "while start * ((nrows-2)*2+2) < len(s):\n",
    "    result.append(start * ((nrows-2)*2+2))\n",
    "    start += 1\n",
    "result = [result]\n",
    "for i in range(nrows):\n",
    "    for x in result[i]:\n",
    "        if x-1 > 0:\n",
    "            tmp.append(x-1)\n",
    "        if x+1 < len(s):\n",
    "            tmp.append(x+1)\n",
    "    result.append(tmp)\n",
    "    tmp = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [],
   "source": [
    "result"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "metadata": {},
   "outputs": [],
   "source": [
    "[''] *3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution(object):\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if numRows == 1 or numRows >= len(s):\n",
    "            return s\n",
    "\n",
    "        L = [''] * numRows\n",
    "        index, step = 0, 1\n",
    "\n",
    "        for x in s:\n",
    "            print(index, step)\n",
    "            L[index] += x\n",
    "            if index == 0:\n",
    "                step = 1\n",
    "            elif index == numRows -1:\n",
    "                step = -1\n",
    "            index += step\n",
    "\n",
    "        return ''.join(L)\n",
    "\n",
    "s = 'abcdefghijklmnopqrstuvwxyz'\n",
    "numRows = 4\n",
    "res = Solution().convert(s)\n",
    "print(res)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution(object):\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if numRows == 1 or numRows >= len(s):\n",
    "            return s\n",
    "\n",
    "        L = [''] * numRows\n",
    "        index, step = 0, 1\n",
    "\n",
    "        for x in s:\n",
    "            print(index, step)\n",
    "            L[index] += x\n",
    "            if index == 0:\n",
    "                step = 1\n",
    "            elif index == numRows -1:\n",
    "                step = -1\n",
    "            index += step\n",
    "\n",
    "        return ''.join(L)\n",
    "\n",
    "s = 'abcdefghijklmnopqrstuvwxyz'\n",
    "numRows = 4\n",
    "res = Solution().convert(s, numRows)\n",
    "print(res)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution(object):\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if numRows == 1 or numRows >= len(s):\n",
    "            return s\n",
    "\n",
    "        L = [''] * numRows\n",
    "        index, step = 0, 1\n",
    "\n",
    "        for x in s:\n",
    "            print(index, step)\n",
    "            print(L)\n",
    "            L[index] += x\n",
    "            if index == 0:\n",
    "                step = 1\n",
    "            elif index == numRows -1:\n",
    "                step = -1\n",
    "            index += step\n",
    "\n",
    "        return ''.join(L)\n",
    "\n",
    "s = 'abcdefghijklmnopqrstuvwxyz'\n",
    "numRows = 4\n",
    "res = Solution().convert(s, numRows)\n",
    "print(res)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution(object):\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "numRows = 4\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= 1 or len(s) <= numRows:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            elif idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "numRows = 4\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "s - 'AB'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= 1 or len(s) <= numRows:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            elif idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "s - 'AB'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "s = 'AB'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= 1 or len(s) <= numRows:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            if idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "s = 'AB'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 156,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= 1 or len(s) <= numRows:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            if idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 157,
   "metadata": {},
   "outputs": [],
   "source": [
    "# s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 158,
   "metadata": {},
   "outputs": [],
   "source": [
    "[''] * 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 159,
   "metadata": {},
   "outputs": [],
   "source": [
    "[''] * 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= numRows or numRows == 1:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            if idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 161,
   "metadata": {},
   "outputs": [],
   "source": [
    "# s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 162,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= numRows or numRows == 1:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            if idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 163,
   "metadata": {},
   "outputs": [],
   "source": [
    "# s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 164,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= numRows:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            if idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {},
   "outputs": [],
   "source": [
    "# s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Solution:\n",
    "    def convert(self, s, numRows):\n",
    "        \"\"\"\n",
    "        :type s: str\n",
    "        :type numRows: int\n",
    "        :rtype: str\n",
    "        \"\"\"\n",
    "        if len(s) <= numRows or numRows == 1:\n",
    "            return s\n",
    "        \n",
    "        idx, step = 0, 1\n",
    "        collect = [''] * numRows\n",
    "        for x in s:\n",
    "            collect[idx] += x\n",
    "            if idx == 0:\n",
    "                step = 1\n",
    "            elif idx == numRows - 1:\n",
    "                step = -1\n",
    "            idx += step\n",
    "        return ''.join(collect)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {},
   "outputs": [],
   "source": [
    "# s = 'PAYPALISHIRING'\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {},
   "outputs": [],
   "source": [
    "s = 'PAYPALISHIRING'\n",
    "numRows = 4\n",
    "s = 'ABC'\n",
    "numRows = 1\n",
    "Solution().convert(s, numRows)"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
